import { Component } from '@angular/core';
import { RichDocumentComponent } from './components/rich-document/rich-document.component';

@Component({
  standalone: true,
  imports: [RichDocumentComponent],
  selector: 'app-root',
  template: `
    <h1>Rich Document Demo</h1>
    <app-rich-document />
  `,
})
export class AppComponent {
}

import { ApplicationConfig, provideZoneChangeDetection } from '@angular/core';
import { provideAnimations } from '@angular/platform-browser/animations';

export const appConfig: ApplicationConfig = {
  providers: [
    provideZoneChangeDetection({ eventCoalescing: true }),
    provideAnimations()
  ],
};

<div class="editable-container">
  <div
    *ngFor="let block of blocks(); let i = index"
    [attr.contenteditable]="true"
    (keydown)="onKeyDown($event, i)"
    (click)="onClick($event)"
    (paste)="onPaste($event, i)"
    class="editable-div"
    #editableDiv>
  </div>
</div>

<button (click)="createBlock(blocks.length)">Add New Block</button>

.editable-container {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.editable-div {
  position: relative;
  min-height: 28px;
  padding: 6px 12px;
  border-radius: 4px;
  font-size: 15px;
  line-height: 1.5;
  color: #292d34;
  transition: all 0.15s ease;
  cursor: text;
  white-space: pre-wrap;
  word-break: break-word;

  &:hover {
    background-color: rgba(55, 125, 255, 0.04);
  }

  &:focus {
    outline: none;
    background-color: #ffffff;
    box-shadow: 0 0 0 2px rgba(55, 125, 255, 0.1);
  }

  &:empty::before {
    content: "Type '/' for commands";
    color: #9ca6af;
    position: absolute;
    pointer-events: none;
  }

  img {
    max-width: 100%;
    height: auto;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s ease;

    &:hover {
      box-shadow: 0 0 0 2px rgba(55, 125, 255, 0.2);
    }

    &.selected {
      box-shadow: 0 0 0 2px #377dff, 0 4px 12px rgba(55, 125, 255, 0.15);
    }
  }

  pre.code-block {
    background: #f6f8fa;
    border-radius: 6px;
    padding: 16px;
    margin: 8px 0;
    font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
    font-size: 14px;
    line-height: 1.45;
    overflow-x: auto;
    cursor: text;

    &:hover {
      background: #f0f3f5;
    }

    &.selected {
      box-shadow: 0 0 0 2px #377dff, 0 4px 12px rgba(55, 125, 255, 0.15);
    }

    code {
      display: block;
      color: #24292e;
      tab-size: 2;
    }
  }
}

/* Dark mode */
@media (prefers-color-scheme: dark) {
  .editable-div {
    color: #e6e9ef;

    &:hover {
      background-color: rgba(55, 125, 255, 0.08);
    }

    &:focus {
      background-color: transparent;
      box-shadow: 0 0 0 2px rgba(55, 125, 255, 0.2);
    }

    &:empty::before {
      color: #6d7175;
    }

    pre.code-block {
      background: #2c2d35;

      &:hover {
        background: #33343d;
      }

      code {
        color: #e6e9ef;
      }
    }
  }
}

import {
  Component,
  Output,
  EventEmitter,
  ViewChildren,
  QueryList,
  ElementRef,
  AfterViewInit,
  Signal,
  OnInit,
  inject
} from '@angular/core';
import { CommonModule, DOCUMENT } from '@angular/common';
import { BlockEvent, Block } from '../../models/block.models';
import { ToolbarState } from '../../models/toolbar.models';
import { BlockService } from '../../services/block.service';
import { ToolbarStateService } from '../../services/toolbar.service';
import { ContentRendererService } from '../../services/content-renderer.service';
import { SelectionService } from '../../services/selection.service';
import { fromEvent, filter } from 'rxjs';
import { FocusManager } from '../../services/focus-manager';
import { BlockKeyboardManager } from '../../services/block-keyboard-manager';
import { PasteManager } from '../../services/paste-manager';
import { ToolbarManager } from '../../services/toolbar-manager';

export const EDITOR_SELECTORS = {
  EDITABLE: '.editable-div',
  TOOLBAR: '.floating-toolbar'
} as const;

@Component({
  selector: 'app-editable-container',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './editable-container.component.html',
  styleUrls: ['./editable-container.component.scss']
})
export class EditableContainerComponent implements AfterViewInit, OnInit {
  @ViewChildren('editableDiv') editableDivRefs!: QueryList<ElementRef>;
  @Output() edit = new EventEmitter<BlockEvent>();
  @Output() toolbarStateChange = new EventEmitter<ToolbarState>();
  blocks: Signal<Block[]>;
  document = inject(DOCUMENT);
  private keyboardManager!: BlockKeyboardManager;
  private focusManager!: FocusManager;
  private pasteManager!: PasteManager;
  private toolbarManager!: ToolbarManager;

  constructor(
    private blockService: BlockService,
    private contentRenderer: ContentRendererService,
    private selectionService: SelectionService,
    private toolbarStateService: ToolbarStateService
  ) {
    this.blockService.createBlock();
    this.blocks = this.blockService.blocks;
  }

  ngOnInit() {
    this.focusManager = new FocusManager(
      this.selectionService,
      this.document
    );
    this.focusManager.setEditableDivRefs(this.editableDivRefs);

    fromEvent<MouseEvent>(document, 'click')
      .pipe(
        filter(event => !this.isClickInside(event.target as Element))
      )
      .subscribe(() => {
        this.toolbarStateService.hideToolbar();
      });
  }

  ngAfterViewInit() {
    this.keyboardManager = new BlockKeyboardManager(
      this.blockService,
      this.focusManager,
      this.editableDivRefs
    );

    this.pasteManager = new PasteManager(
      this.blockService,
      this.contentRenderer,
      this.editableDivRefs,
      this.document,
      this.edit
    );

    this.toolbarManager = new ToolbarManager(
      this.selectionService,
      this.toolbarStateService
    );

    this.editableDivRefs.changes
      .pipe(
        filter(() => this.focusManager.hasPendingFocus())
      )
      .subscribe(() => {
        // Update refs when they change
        this.focusManager.setEditableDivRefs(this.editableDivRefs);
        const index = this.focusManager.getPendingIndex();
        if (index !== null) {
          this.focusManager.focusBlock(index);
        }
      });
  }

  createBlock(index: number): void {
    this.blockService.createBlock();
    this.focusManager.requestFocus(index + 1);
  }

  onKeyDown(event: KeyboardEvent, index: number): void {
    this.keyboardManager.handleKeyDown(event, index);
  }


  onClick(event: MouseEvent) {
    this.toolbarManager.handleClick(event.target as HTMLElement);
  }

  onPaste(event: ClipboardEvent, index: number) {
    this.pasteManager.handlePaste(event, index);
  }

  private focusBlock(index: number): void {
    const divs = this.editableDivRefs.toArray();
    if (divs[index]) {
      const div = divs[index].nativeElement;
      div.focus();
      this.selectionService.focusAtEnd(div);
    }
  }

  private isClickInside(target: Element): boolean {
    return Boolean(
      target.closest(EDITOR_SELECTORS.EDITABLE) ||
      target.closest(EDITOR_SELECTORS.TOOLBAR)
    );
  }
}

<h2>Title</h2>
<p>Description: This is description.</p>
<p>Author: Michal Grzegorczyk</p>

import { Component } from '@angular/core';

@Component({
  selector: 'app-header',
  templateUrl: './header.component.html',
  standalone: true
})
export class HeaderComponent {
}

<app-header />
<app-toolbar [state]="toolbarStateService.state$ | async"  (action)="toolbarAction($event)" />
<app-editable-container  />

:host {
  display: block;
  padding: 20px;
  border: 1px solid #ccc;
  //background: red;
}

import { Component, ChangeDetectorRef } from '@angular/core';
import { AsyncPipe, NgForOf, CommonModule } from '@angular/common';
import { EditableContainerComponent } from '../editable-container/editable-container.component';
import { HeaderComponent } from '../header/header.component';
import { ToolbarComponent } from '../toolbar/toolbar.component';
import { ToolbarState } from '../../models/toolbar.models';
import { ToolbarStateService } from '../../services/toolbar.service';
import { RouterModule } from '@angular/router';

@Component({
  selector: 'app-rich-document',
  templateUrl: './rich-document.component.html',
  styleUrls: ['./rich-document.component.scss'],
  imports: [
    RouterModule, NgForOf, CommonModule, HeaderComponent, ToolbarComponent, EditableContainerComponent,
    AsyncPipe,
    EditableContainerComponent,
    HeaderComponent,
    ToolbarComponent
  ],
  standalone: true
})
export class RichDocumentComponent {
  selectedImageElement: HTMLImageElement | null = null;

  toolbarState: ToolbarState = {
    show: false,
    isTextSelection: false,
    isImageSelected: false,
    isCodeBlock: false,
    position: { top: 0, left: 0 }
  };

  constructor(
    private cdr: ChangeDetectorRef,
    public toolbarStateService: ToolbarStateService
  ) {}

  toolbarAction(event: {type: string, value: string}) {

    console.log(`Toolbar action: ${event.type} - ${event.value}`); // General log for any toolbar action
    switch (event.type) {
      case 'format':
        this.formatText(event.value as 'bold' | 'italic');
        break;
      case 'image':
        this.handleImageOptions(event.value);
        break;
      case 'code':
        this.handleCodeOptions(event.value);
        break;
    }
  }

  formatText(format: 'bold' | 'italic') {
    document.execCommand(format, false);
  }

  private handleCodeOptions(value: string) {

  }

  private showImageEditingToolbar(imageElement: HTMLImageElement): void {
    console.log("Displaying image editing toolbar for:", imageElement.src);
    // Here you can expand functionality, for now, it logs the action
    const rect = imageElement.getBoundingClientRect();
    this.toolbarState = {
      show: true,
      isTextSelection: false,
      isImageSelected: true,
      isCodeBlock: false,
      position: { top: rect.bottom + 10, left: rect.left }
    };
    this.cdr.detectChanges();
  }
  private handleImageOptions(value: string): void {
    console.log("Image options clicked:", value);
    if (this.selectedImageElement) {
      this.showImageEditingToolbar(this.selectedImageElement);
    } else {
      console.log("No image is selected when trying to access image options.");
    }
  }
}

<div *ngIf="state?.show" class="floating-toolbar" [style.top.px]="state?.position?.top" [style.left.px]="state?.position?.left">
  <div *ngIf="state?.isTextSelection" class="toolbar-group">
    <button (click)="handleAction('format', 'bold')" class="toolbar-button">
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"/>
        <path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"/>
      </svg>
    </button>
    <button (click)="handleAction('format', 'italic')" class="toolbar-button">
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="19" y1="4" x2="10" y2="4"/>
        <line x1="14" y1="20" x2="5" y2="20"/>
        <line x1="15" y1="4" x2="9" y2="20"/>
      </svg>
    </button>
  </div>
  <div *ngIf="state?.isImageSelected" class="toolbar-group">
    <button (click)="handleAction('image', 'options')" class="toolbar-button">Image Options</button>
  </div>
  <div *ngIf="state?.isCodeBlock" class="toolbar-group">
    <button (click)="handleAction('code', 'theme')" class="toolbar-button">
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
      </svg>
      Change Theme
    </button>
    <button (click)="handleAction('code', 'copy')" class="toolbar-button">
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/>
        <rect x="8" y="2" width="8" height="4" rx="1" ry="1"/>
      </svg>
      Copy
    </button>
  </div>
</div>

// toolbar.component.scss
.floating-toolbar {
  position: fixed;
  background: white;
  border-radius: 6px;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
  padding: 6px;
  z-index: 1000;
  display: flex;
  gap: 4px;
  transition: all 0.1s ease;
  border: 1px solid #e8ecef;
}

.toolbar-group {
  display: flex;
  gap: 4px;
}

.toolbar-button {
  padding: 6px;
  background: transparent;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  color: #292d34;
  display: flex;
  align-items: center;
  justify-content: center;

  &:hover {
    background-color: #f0f3f5;
  }

  svg {
    width: 16px;
    height: 16px;
  }
}

import { Component, Input, Output, EventEmitter, ChangeDetectorRef } from '@angular/core';
import { NgIf, AsyncPipe } from '@angular/common';
import { ToolbarState } from '../../models/toolbar.models';
import { ToolbarStateService } from '../../services/toolbar.service';

@Component({
  selector: 'app-toolbar',
  templateUrl: './toolbar.component.html',
  styleUrls: ['./toolbar.component.scss'],
  imports: [NgIf, AsyncPipe],
  standalone: true
})
export class ToolbarComponent {
  @Input() state!: ToolbarState | null;
  @Output() action = new EventEmitter<{type: string, value: string}>();


  constructor(
    public toolbarStateService: ToolbarStateService,
    public cdr: ChangeDetectorRef
  ) {
  }

  selectedImageElement: HTMLImageElement | null = null;

  toolbarState: ToolbarState = {
    show: false,
    isTextSelection: false,
    isImageSelected: false,
    isCodeBlock: false,
    position: { top: 0, left: 0 }
  };


  handleAction(type: string, value: string) {
    console.log(`Toolbar action: ${type} - ${value}`);
    this.toolbarAction({ type, value });
  }

  toolbarAction(event: {type: string, value: string}) {

    console.log(`Toolbar action: ${event.type} - ${event.value}`); // General log for any toolbar action
    switch (event.type) {
      case 'format':
        this.formatText(event.value as 'bold' | 'italic');
        break;
      case 'image':
        this.handleImageOptions(event.value);
        break;
      case 'code':
        this.handleCodeOptions(event.value);
        break;
    }
  }


  formatText(format: 'bold' | 'italic') {
    document.execCommand(format, false);
  }

  private handleCodeOptions(value: string) {

  }



  private handleImageOptions(value: string): void {
    console.log("Image options clicked:", value);
    if (this.selectedImageElement) {
      this.showImageEditingToolbar(this.selectedImageElement);
    } else {
      console.log("No image is selected when trying to access image options.");
    }
  }

  private showImageEditingToolbar(imageElement: HTMLImageElement): void {
    console.log("Displaying image editing toolbar for:", imageElement.src);
    // Here you can expand functionality, for now, it logs the action
    const rect = imageElement.getBoundingClientRect();
    this.toolbarState = {
      show: true,
      isTextSelection: false,
      isImageSelected: true,
      isCodeBlock: false,
      position: { top: rect.bottom + 10, left: rect.left }
    };
    this.cdr.detectChanges();
  }

}

import { BlockType } from './types';

export interface Block {
  id: number;
  type: BlockType;
  content: string;
}

export interface BlockEvent {
  type: BlockType;
  content: string;
  index: number;
}

import { ToolbarActionType } from './types';

export interface ToolbarState {
  show: boolean;
  isTextSelection: boolean;
  isImageSelected: boolean;
  isCodeBlock: boolean;
  position: Position;
}

export interface ToolbarAction {
  type: ToolbarActionType;
  value: string;
}

export interface Position {
  top: number;
  left: number;
}

export type BlockType = 'text' | 'image' | 'code';
export type ToolbarActionType = 'format' | 'image' | 'code';

import { BlockService } from './block.service';
import { FocusManager } from './focus-manager';
import { QueryList, ElementRef } from '@angular/core';

export interface KeyHandler {
  key: string;
  modifier?: 'shift' | 'ctrl' | 'alt';
  required?: boolean;  // if true, modifier must be present; if false, modifier must not be present
  handle: (event: KeyboardEvent, index: number) => void;
  shouldHandle: (event: KeyboardEvent) => boolean;
}


export class BlockKeyboardManager {
  constructor(
    private readonly blockService: BlockService,
    private readonly focusManager: FocusManager,
    private readonly editableDivRefs: QueryList<ElementRef>
  ) {}

  private readonly keyHandlers: KeyHandler[] = [
    {
      key: 'Enter',
      modifier: 'shift',
      shouldHandle: (event) => !event.shiftKey,  // On
      required: false,
      handle: (event, index) => {
        event.preventDefault();
        this.createBlock(index);
      }
    },
    {
      key: 'Backspace',
      shouldHandle: () => true,  // Always check ba
      handle: (event, index) => {
        console.log('x');
        if (this.isEmptyBlock(index) && this.blockService.blocks().length > 1) {
          event.preventDefault();
          this.deleteBlock(index);
        }
      }
    }
  ];

  handleKeyDown(event: KeyboardEvent, index: number): void {
    const handler = this.findMatchingHandler(event);
    if (handler) {
      handler.handle(event, index);
    }
  }

  private findMatchingHandler(event: KeyboardEvent): KeyHandler | undefined {
    return this.keyHandlers.find(handler =>
      handler.key === event.key && handler.shouldHandle(event)
    );
  }

  private createBlock(index: number): void {
    this.blockService.createBlock();
    this.focusManager.requestFocus(index + 1);
  }

  private deleteBlock(index: number): void {
    if (index > 0) {
      this.blockService.removeBlock(index);
      this.focusManager.requestFocus(index - 1);
    }
  }

  private isEmptyBlock(index: number): boolean {
    const div = this.editableDivRefs.get(index)?.nativeElement;
    return Boolean(div?.textContent?.trim() === '');
  }
}

import { Injectable, signal } from '@angular/core';
import { Block } from '../models/block.models';

@Injectable({
  providedIn: 'root'
})
export class BlockService {
  blocks = signal<Block[]>([]);

  private nextId = 1;

  createBlock(): void {
    const newBlock :Block= {
      id: this.nextId++,
      type: 'text',
      content: ''
    };

    this.blocks.set([...this.blocks(), newBlock]);
  }

  isCodeContent(text: string): boolean {
    const codeIndicators = [
      '{', '}', ';', '//', '/*', '*/',
      'function', 'const', 'let', 'var',
      'class', 'import', 'export',
      '</', '/>'
    ];
    return codeIndicators.some(indicator => text.includes(indicator)) &&
      text.split('\n').length > 1;
  }

  removeBlock(index: number) {
    this.blocks.set(this.blocks().filter((_:Block, i:number) => i !== index));
  }
}

import { Injectable, Renderer2, RendererFactory2 } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class ContentRendererService {
  private renderer: Renderer2;

  constructor(rendererFactory: RendererFactory2) {
    this.renderer = rendererFactory.createRenderer(null, null);
  }

  renderCodeBlock(container: HTMLElement, code: string): void {
    const pre = this.renderer.createElement('pre');
    const codeElement = this.renderer.createElement('code');

    this.renderer.addClass(pre, 'code-block');
    this.renderer.setProperty(codeElement, 'textContent', code);
    this.renderer.appendChild(pre, codeElement);
    this.renderer.appendChild(container, pre);
  }
}

import { BehaviorSubject } from 'rxjs';
import { QueryList, ElementRef } from '@angular/core';
import { SelectionService } from './selection.service';

interface FocusOptions {
  position?: 'start' | 'end' | number;
  smooth?: boolean;
  preventScroll?: boolean;
}

export class FocusManager {
  private readonly pendingFocusSubject = new BehaviorSubject<number | null>(null);
  private readonly activeBlockSubject = new BehaviorSubject<number | null>(null);
  private editableDivRefs?: QueryList<ElementRef<HTMLDivElement>>;

  readonly pendingFocus$ = this.pendingFocusSubject.asObservable();
  readonly activeBlock$ = this.activeBlockSubject.asObservable();

  private readonly defaultOptions: FocusOptions = {
    position: 'end',
    smooth: true,
    preventScroll: false
  };

  constructor(
    private readonly selectionService: SelectionService,
    private readonly document: Document
  ) {}

  setEditableDivRefs(refs: QueryList<ElementRef<HTMLDivElement>>) {
    this.editableDivRefs = refs;
  }

  requestFocus(index: number, options: FocusOptions = this.defaultOptions): void {
    // Always queue the focus request if refs aren't set yet
    if (!this.editableDivRefs) {
      this.pendingFocusSubject.next(index);
      return;
    }

    if (this.canFocusImmediately(index)) {
      this.focusBlock(index, options);
    } else {
      this.pendingFocusSubject.next(index);
    }
  }

  getPendingIndex(): number | null {
    return this.pendingFocusSubject.value;
  }

  getActiveBlock(): number | null {
    return this.activeBlockSubject.value;
  }

  hasPendingFocus(): boolean {
    return this.getPendingIndex() !== null;
  }

  clear(): void {
    this.pendingFocusSubject.next(null);
  }

  focusBlock(index: number, options: FocusOptions = this.defaultOptions): boolean {
    try {
      if (!this.editableDivRefs || !this.isValidIndex(index)) {
        console.warn(`Cannot focus block: ${!this.editableDivRefs ? 'Refs not set' : 'Invalid index'}`);
        return false;
      }

      const div = this.getBlockElement(index);
      if (!div) {
        if (!this.hasPendingFocus()) {
          this.pendingFocusSubject.next(index);
        }
        return false;
      }

      const currentFocused = this.document.activeElement;
      if (currentFocused === div) {
        return true;
      }

      this.applyFocus(div, options);
      this.activeBlockSubject.next(index);
      this.clear();

      if (!options.preventScroll) {
        this.scrollIntoView(div, options.smooth);
      }

      return true;
    } catch (error) {
      console.error('Error focusing block:', error);
      return false;
    }
  }

  private canFocusImmediately(index: number): boolean {
    return Boolean(this.editableDivRefs) &&
      this.isValidIndex(index) &&
      Boolean(this.getBlockElement(index));
  }

  private isValidIndex(index: number): boolean {
    return Boolean(
      this.editableDivRefs &&
      Number.isInteger(index) &&
      index >= 0 &&
      index < this.editableDivRefs.length
    );
  }

  private getBlockElement(index: number): HTMLDivElement | null {
    return this.editableDivRefs?.get(index)?.nativeElement || null;
  }

  private applyFocus(element: HTMLDivElement, options: FocusOptions): void {
    element.focus();

    const { position } = options;
    if (position === 'start') {
      // Implement focusAtStart when needed
    } else if (position === 'end') {
      this.selectionService.focusAtEnd(element);
    } else if (typeof position === 'number') {
      // Implement focusAtPosition when needed
    }
  }

  private scrollIntoView(element: HTMLDivElement, smooth: boolean = true): void {
    const rect = element.getBoundingClientRect();
    const isVisible =
      rect.top >= 0 &&
      rect.left >= 0 &&
      rect.bottom <= (window.innerHeight || this.document.documentElement.clientHeight) &&
      rect.right <= (window.innerWidth || this.document.documentElement.clientWidth);

    if (!isVisible) {
      element.scrollIntoView({
        behavior: smooth ? 'smooth' : 'auto',
        block: 'nearest',
        inline: 'nearest'
      });
    }
  }
}

import { BlockService } from './block.service';
import { ContentRendererService } from './content-renderer.service';
import { QueryList, ElementRef, EventEmitter } from '@angular/core';
import { BlockEvent } from '../models/block.models';

export class PasteManager {
  constructor(
    private blockService: BlockService,
    private contentRenderer: ContentRendererService,
    private editableDivRefs: QueryList<ElementRef>,
    private document: Document,
    private edit: EventEmitter<BlockEvent>
  ) {}

  handlePaste(event: ClipboardEvent, index: number): void {
    event.preventDefault();

    const text = event.clipboardData?.getData('text/plain');
    if (text) {
      this.handleTextPaste(text, index);
    } else {
      this.handleImagePaste(event, index);
    }
  }

  private handleTextPaste(text: string, index: number): void {
    if (this.blockService.isCodeContent(text)) {
      this.insertCodeBlock(text, index);
    } else {
      document.execCommand('insertText', false, text);
    }
  }

  private handleImagePaste(event: ClipboardEvent, index: number): void {
    const items = event.clipboardData?.items;
    if (!items) return;

    for (let i = 0; i < items.length; i++) {
      if (items[i].type.indexOf('image') !== -1) {
        const file = items[i].getAsFile();
        if (file) {
          this.insertImage(file, index);
        }
      }
    }
  }

  private insertCodeBlock(code: string, index: number): void {
    const div = this.editableDivRefs.get(index)?.nativeElement;
    if (div) {
      this.contentRenderer.renderCodeBlock(div, code);
      this.edit.emit({
        type: 'code',
        content: code,
        index
      });
    }
  }

  private insertImage(file: File, index: number): void {
    const reader = new FileReader();
    reader.onload = (e: ProgressEvent<FileReader>) => {
      const div = this.editableDivRefs.get(index)?.nativeElement;
      if (div && e.target?.result) {
        const img = this.document.createElement('img');
        img.src = e.target.result as string;
        div.appendChild(img);

        this.edit.emit({
          type: 'image',
          content: e.target.result as string,
          index
        });
      }
    };
    reader.readAsDataURL(file);
  }
}

import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class SelectionService {
  getSelectionInfo(): { range: Range, rect: DOMRect } | null {
    const selection = window.getSelection();
    if (selection && selection.rangeCount > 0) {
      const range = selection.getRangeAt(0);
      const rect = range.getBoundingClientRect();
      return { range, rect };
    }
    return null;
  }

  hasTextSelection(): boolean {
    const selection = window.getSelection();
    return !!(selection && selection.toString().trim().length > 0);
  }

  getElementRect(element: HTMLElement): DOMRect {
    return element.getBoundingClientRect();
  }

  adjustToolbarPosition(rect: DOMRect): { top: number; left: number } {
    const toolbarWidth = 200;
    const toolbarHeight = 40;
    const padding = 16;
    const viewport = {
      width: window.innerWidth,
      height: window.innerHeight
    };

    let left = rect.left + (rect.width / 2) - (toolbarWidth / 2);
    let top = rect.top - toolbarHeight - padding;

    // Adjust horizontal position if toolbar would be off-screen
    if (left + toolbarWidth > viewport.width - padding) {
      left = viewport.width - toolbarWidth - padding;
    }
    if (left < padding) {
      left = padding;
    }

    // Adjust vertical position if toolbar would be off-screen
    if (top < padding) {
      top = rect.bottom + padding; // Show below instead of above
    }

    return { top, left };
  }

  focusAtEnd(element: HTMLElement) {
    const range = document.createRange();
    range.selectNodeContents(element);
    range.collapse(false);

    const selection = window.getSelection();
    if (selection) {
      selection.removeAllRanges();
      selection.addRange(range);
    }
  }

  unsetSelection() {
    window.getSelection()?.removeAllRanges();
  }
}

// toolbar-manager.service.ts
import { SelectionService } from './selection.service';
import { ToolbarStateService } from './toolbar.service';

export class ToolbarManager {
  constructor(
    private selectionService: SelectionService,
    private toolbarStateService: ToolbarStateService
  ) {}
  //todo: toolbar poczyscic

  handleClick(target: HTMLElement): void {
    if (target.tagName === 'IMG') {
      this.handleImageClick(target as HTMLImageElement);
    } else if (target.closest('pre')) {
      this.handleCodeClick(target.closest('pre') as HTMLElement);
      this.handleTextSelection();
    } else {
      this.handleTextSelection();
    }
  }

  private handleImageClick(image: HTMLImageElement) {
    this.selectionService.unsetSelection();
    const rect = this.selectionService.getElementRect(image);
    const position = this.selectionService.adjustToolbarPosition(rect);
    this.toolbarStateService.showImageToolbar(position);
  }

  private handleCodeClick(codeBlock: HTMLElement) {
    const rect = this.selectionService.getElementRect(codeBlock);
    const position = this.selectionService.adjustToolbarPosition(rect);
    this.toolbarStateService.showCodeToolbar(position);
  }

  private handleTextSelection() {
    if (this.selectionService.hasTextSelection()) {
      const selectionInfo = this.selectionService.getSelectionInfo();
      if (selectionInfo) {
        const position = this.selectionService.adjustToolbarPosition(selectionInfo.rect);
        this.toolbarStateService.showTextToolbar(position);
      }
    }
  }
}

import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { ToolbarState } from '../models/toolbar.models';

const initialToolbarState: ToolbarState = {
  show: false,
  isTextSelection: false,
  isImageSelected: false,
  isCodeBlock: false,
  position: { top: 0, left: 0 }
};

@Injectable({
  providedIn: 'root'
})
export class ToolbarStateService {
  private state = new BehaviorSubject<ToolbarState>(initialToolbarState);
  state$ = this.state.asObservable();

  showTextToolbar(position: { top: number; left: number }) {
    this.state.next({
      show: true,
      isTextSelection: true,
      isImageSelected: false,
      isCodeBlock: false,
      position
    });
  }

  showImageToolbar(position: { top: number; left: number }) {
    this.state.next({
      show: true,
      isTextSelection: false,
      isImageSelected: true,
      isCodeBlock: false,
      position
    });
  }

  showCodeToolbar(position: { top: number; left: number }) {
    this.state.next({
      show: true,
      isTextSelection: false,
      isImageSelected: false,
      isCodeBlock: true,
      position
    });
  }

  hideToolbar() {
    this.state.next(initialToolbarState);
  }
}

